//--from
	// Install g (= m->g0) and set the stack bounds
	// to match the current stack. If we don't actually know
	// how big the stack is, like we don't know how big any
	// scheduling stack is, but we assume there's at least 32 kB.
	// If we can get a more accurate stack bound from pthread,
	// use that.
	setg(mp.g0)
	gp := getg()
	gp.stack.hi = getcallersp() + 1024
	gp.stack.lo = getcallersp() - 32*1024
	if !signal && _cgo_getstackbound != nil {
		// Don't adjust if called from the signal handler.
		// We are on the signal stack, not the pthread stack.
		// (We could get the stack bounds from sigaltstack, but
		// we're getting out of the signal handler very soon
		// anyway. Not worth it.)
		var bounds [2]uintptr
		asmcgocall(_cgo_getstackbound, unsafe.Pointer(&bounds))
		// getstackbound is an unsupported no-op on Windows.
		if bounds[0] != 0 {
			gp.stack.lo = bounds[0]
			gp.stack.hi = bounds[1]
		}
	}
	gp.stackguard0 = gp.stack.lo + stackGuard
//--to
	// This change is from https://go-review.googlesource.com/c/go/+/527715.

	// Install g (= m->g0) and set the stack bounds
	// to match the current stack.
	setg(mp.g0)
	sp := getcallersp()
	callbackUpdateSystemStack(mp, sp, signal)
//--from
// NOTE: this always runs without a P, so, nowritebarrierrec required.
//
//go:nowritebarrierrec
func dropm() {
//--to
// This change is from https://go-review.googlesource.com/c/go/+/527715.
//
// This always runs without a P, so //go:nowritebarrierrec is required.
//
// This may run with a different stack than was recorded in g0 (there is no
// call to callbackUpdateSystemStack prior to dropm), so this must be
// //go:nosplit to avoid the stack bounds check.
//
//go:nowritebarrierrec
//go:nosplit
func dropm() {
